export default MindMap;
declare class MindMap {
    /**
     *
     * @param {defaultOpt} opt
     */
    constructor(opt?: {
        el: any;
        data: any;
        viewData: any;
        readonly: boolean;
        layout: string;
        fishboneDeg: number;
        theme: string;
        themeConfig: {};
        scaleRatio: number;
        translateRatio: number;
        minZoomRatio: number;
        maxZoomRatio: number;
        customCheckIsTouchPad: any;
        mouseScaleCenterUseMousePosition: boolean;
        maxTag: number;
        expandBtnSize: number;
        imgTextMargin: number;
        textContentMargin: number;
        customNoteContentShow: any;
        textAutoWrapWidth: number;
        customHandleMousewheel: any;
        mousewheelAction: string;
        mousewheelMoveStep: number;
        mousewheelZoomActionReverse: boolean;
        defaultInsertSecondLevelNodeText: string;
        defaultInsertBelowSecondLevelNodeText: string;
        expandBtnStyle: {
            color: string;
            fill: string;
            fontSize: number;
            strokeColor: string;
        };
        expandBtnIcon: {
            open: string;
            close: string;
        };
        expandBtnNumHandler: any;
        isShowExpandNum: boolean;
        enableShortcutOnlyWhenMouseInSvg: boolean;
        customCheckEnableShortcut: any;
        initRootNodePosition: any;
        nodeTextEditZIndex: number;
        nodeNoteTooltipZIndex: number;
        isEndNodeTextEditOnClickOuter: boolean;
        maxHistoryCount: number;
        alwaysShowExpandBtn: boolean;
        notShowExpandBtn: boolean;
        iconList: any[];
        maxNodeCacheCount: number;
        fitPadding: number;
        enableCtrlKeyNodeSelection: boolean;
        useLeftKeySelectionRightKeyDrag: boolean;
        beforeTextEdit: any;
        isUseCustomNodeContent: boolean;
        customCreateNodeContent: any;
        customInnerElsAppendTo: any;
        enableAutoEnterTextEditWhenKeydown: boolean;
        autoEmptyTextWhenKeydownEnterEdit: boolean;
        customHandleClipboardText: any;
        disableMouseWheelZoom: boolean;
        errorHandler: (code: any, error: any) => void;
        enableDblclickBackToRootNode: boolean;
        hoverRectColor: string;
        hoverRectPadding: number;
        selectTextOnEnterEditText: boolean;
        deleteNodeActive: boolean;
        fit: boolean;
        tagsColorMap: {};
        cooperateStyle: {
            avatarSize: number;
            fontSize: number;
        };
        onlyOneEnableActiveNodeOnCooperate: boolean;
        defaultGeneralizationText: string;
        handleIsSplitByWrapOnPasteCreateNewNode: any;
        addHistoryTime: number;
        isDisableDrag: boolean;
        createNewNodeBehavior: string;
        defaultNodeImage: string;
        isLimitMindMapInCanvas: boolean;
        handleNodePasteImg: any;
        customCreateNodePath: any;
        customCreateNodePolygon: any;
        customTransformNodeLinePath: any;
        beforeShortcutRun: any;
        resetScaleOnMoveNodeToCenter: boolean;
        createNodePrefixContent: any;
        createNodePostfixContent: any;
        disabledClipboard: boolean;
        customHyperlinkJump: any;
        openPerformance: boolean;
        performanceConfig: {
            time: number;
            padding: number;
            removeNodeWhenOutCanvas: boolean;
        };
        emptyTextMeasureHeightText: string;
        openRealtimeRenderOnNodeTextEdit: boolean;
        mousedownEventPreventDefault: boolean;
        onlyPasteTextWhenHasImgAndText: boolean;
        enableDragModifyNodeWidth: boolean;
        minNodeTextModifyWidth: number;
        maxNodeTextModifyWidth: number;
        customHandleLine: any;
        addHistoryOnInit: boolean;
        noteIcon: {
            icon: string;
            style: {};
        };
        hyperlinkIcon: {
            icon: string;
            style: {};
        };
        attachmentIcon: {
            icon: string;
            style: {};
        };
        isShowCreateChildBtnIcon: boolean;
        quickCreateChildBtnIcon: {
            icon: string;
            style: {};
        };
        customQuickCreateChildBtnClick: any;
        addCustomContentToNode: any;
        enableInheritAncestorLineStyle: boolean;
        selectTranslateStep: number;
        selectTranslateLimit: number;
        enableFreeDrag: boolean;
        autoMoveWhenMouseInEdgeOnDrag: boolean;
        dragMultiNodeRectConfig: {
            width: number;
            height: number;
            fill: string;
        };
        dragPlaceholderRectFill: string;
        dragPlaceholderLineConfig: {
            color: string;
            width: number;
        };
        dragOpacityConfig: {
            cloneNodeOpacity: number;
            beingDragNodeOpacity: number;
        };
        handleDragCloneNode: any;
        beforeDragEnd: any;
        beforeDragStart: any;
        watermarkConfig: {
            onlyExport: boolean;
            text: string;
            lineSpacing: number;
            textSpacing: number;
            angle: number;
            textStyle: {
                color: string;
                opacity: number;
                fontSize: number;
            };
            belowNode: boolean;
        };
        exportPaddingX: number;
        exportPaddingY: number;
        resetCss: string;
        minExportImgCanvasScale: number;
        addContentToHeader: any;
        addContentToFooter: any;
        handleBeingExportSvg: any;
        maxCanvasSize: number;
        defaultAssociativeLineText: string;
        associativeLineIsAlwaysAboveNode: boolean;
        associativeLineInitPointsPosition: {
            from: string;
            to: string;
        };
        enableAdjustAssociativeLinePoints: boolean;
        beforeAssociativeLineConnection: any;
        disableTouchZoom: boolean;
        minTouchZoomScale: number;
        maxTouchZoomScale: number;
        isLimitMindMapInCanvasWhenHasScrollbar: boolean;
        isOnlySearchCurrentRenderNodes: boolean;
        beforeCooperateUpdate: any;
        rainbowLinesConfig: {
            open: boolean;
            colorsList: any[];
        };
        demonstrateConfig: any;
        enableEditFormulaInRichTextEdit: boolean;
        katexFontPath: string;
        getKatexOutputType: any;
        transformRichTextOnEnterEdit: any;
        beforeHideRichTextEdit: any;
        outerFramePaddingX: number;
        outerFramePaddingY: number;
        onlyPainterNodeCustomStyles: boolean;
        beforeDeleteNodeImg: any;
        imgResizeBtnSize: number;
        minImgResizeWidth: number;
        minImgResizeHeight: number;
        maxImgResizeWidthInheritTheme: boolean;
        maxImgResizeWidth: number;
        maxImgResizeHeight: number;
        customDeleteBtnInnerHTML: string;
        customResizeBtnInnerHTML: string;
    });
    opt: any;
    el: any;
    initWidth: any;
    initHeight: any;
    cssEl: HTMLStyleElement;
    cssTextMap: {};
    nodeInnerPrefixList: any[];
    event: Event;
    keyCommand: KeyCommand;
    command: Command;
    renderer: Render;
    view: View;
    batchExecution: BatchExecution;
    handleOpt(opt: any): any;
    handleData(data: any): any;
    initContainer(): void;
    associativeLineDraw: any;
    svg: any;
    draw: any;
    lineDraw: any;
    nodeDraw: any;
    otherDraw: any;
    clearDraw(): void;
    appendCss(key: any, str: any): void;
    removeAppendCss(key: any): void;
    joinCss(): string;
    addCss(): void;
    removeCss(): void;
    render(callback: any, source?: string): void;
    reRender(callback: any, source?: string): void;
    getElRectInfo(): void;
    elRect: any;
    width: any;
    height: any;
    resize(): void;
    on(event: any, fn: any): void;
    emit(event: any, ...args: any[]): void;
    off(event: any, fn: any): void;
    initCache(): void;
    commonCaches: {
        measureCustomNodeContentSizeEl: any;
        measureRichtextNodeTextSizeEl: any;
    };
    initTheme(): void;
    themeConfig: any;
    setTheme(theme: any, notRender?: boolean): void;
    getTheme(): any;
    setThemeConfig(config: any, notRender?: boolean): void;
    getCustomThemeConfig(): any;
    getThemeConfig(prop: any): any;
    getConfig(prop: any): any;
    updateConfig(opt?: {}): void;
    getLayout(): any;
    setLayout(layout: any, notRender?: boolean): void;
    execCommand(...args: any[]): void;
    updateData(data: any): void;
    setData(data: any): void;
    setFullData(data: any): void;
    getData(withConfig: any): any;
    export(...args: any[]): Promise<any>;
    toPos(x: any, y: any): {
        x: number;
        y: number;
    };
    setMode(mode: any): void;
    getSvgData({ paddingX, paddingY, ignoreWatermark, addContentToHeader, addContentToFooter, node }?: {
        paddingX?: number;
        paddingY?: number;
        ignoreWatermark?: boolean;
        addContentToHeader: any;
        addContentToFooter: any;
        node: any;
    }): {
        svg: any;
        svgHTML: any;
        clipData: any;
        rect: any;
        origWidth: any;
        origHeight: any;
        scaleX: any;
        scaleY: any;
    };
    addPlugin(plugin: any, opt: any): void;
    removePlugin(plugin: any): void;
    initPlugin(plugin: any): void;
    destroy(): void;
}
declare namespace MindMap {
    const pluginList: any[];
    function usePlugin(plugin: any, opt?: {}): typeof MindMap;
    function hasPlugin(plugin: any): number;
    const instanceCount: number;
    function defineTheme(name: any, config?: {}): Error;
    function removeTheme(name: any): void;
}
import Event from "./src/core/event/Event";
import KeyCommand from "./src/core/command/KeyCommand";
import Command from "./src/core/command/Command";
import Render from "./src/core/render/Render";
import View from "./src/core/view/View";
import BatchExecution from "./src/utils/BatchExecution";
